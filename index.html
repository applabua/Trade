<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Простая торговая программа (MEXC)</title>
  <!-- Подключаем Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<canvas id="chart" width="800" height="400"></canvas>
<div id="error" style="color:red;"></div>

<script>
// Параметры скользящих средних
const shortPeriod = 10; // короткая MA
const longPeriod = 50;  // длинная MA

// Функция для запроса данных у MEXC (спот)
async function fetchData() {
  // Пример: BTCUSDT, интервал 1 час, 100 свечей
  const url = 'https://api.mexc.com/api/v3/klines?symbol=BTCUSDT&interval=1h&limit=100';
  try {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error('HTTP Error ' + resp.status);
    const data = await resp.json(); // массив массивов
    return data;
  } catch (err) {
    document.getElementById('error').textContent = 'Не удалось загрузить данные: ' + err;
    return [];
  }
}

// Скользящая средняя по цене закрытия
function calcMA(data, period) {
  const result = [];
  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      result.push(null); // недостаточно точек
      continue;
    }
    let sum = 0;
    for (let j = i - period + 1; j <= i; j++) {
      sum += parseFloat(data[j][4]); // индекс 4 = close
    }
    result.push(sum / period);
  }
  return result;
}

// Ищем «точки входа»: короткая MA пересекает длинную снизу вверх
function findEntrySignals(shortMA, longMA) {
  const signals = [];
  for (let i = 1; i < shortMA.length; i++) {
    if (
      shortMA[i-1] != null && longMA[i-1] != null &&
      shortMA[i] != null && longMA[i] != null
    ) {
      // пересечение снизу вверх
      if (shortMA[i-1] <= longMA[i-1] && shortMA[i] > longMA[i]) {
        signals.push(i);
      }
    }
  }
  return signals;
}

let chart;        // будет хранить экземпляр Chart.js
let entrySignals; // массив индексов для оранжевых линий
let labels;       // массив подписей (даты)

// Функция для построения/обновления графика
function drawChart(closes, shortMA, longMA, signals) {
  const ctx = document.getElementById('chart').getContext('2d');
  labels = labels || closes.map((_, i) => i); // на случай, если дат нет

  // Если график уже создан — обновляем данные
  if (chart) {
    chart.data.datasets[0].data = closes;
    chart.data.datasets[1].data = shortMA;
    chart.data.datasets[2].data = longMA;
    entrySignals = signals;
    chart.update();
    return;
  }

  // Создаём новый
  chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'Цена закрытия',
          data: closes,
          borderColor: 'blue',
          fill: false
        },
        {
          label: `MA(${shortPeriod})`,
          data: shortMA,
          borderColor: 'green',
          fill: false
        },
        {
          label: `MA(${longPeriod})`,
          data: longMA,
          borderColor: 'red',
          fill: false
        }
      ]
    },
    options: {
      responsive: true,
      plugins: {
        tooltip: {
          mode: 'index',
          intersect: false
        }
      }
    }
  });

  // Сохраняем индексы точек входа
  entrySignals = signals;

  // Плагин для оранжевых вертикальных линий
  const verticalLinePlugin = {
    id: 'verticalLinePlugin',
    afterDraw: (chart) => {
      const { ctx, chartArea: { top, bottom }, scales: { x } } = chart;
      ctx.save();
      ctx.strokeStyle = 'orange';
      ctx.lineWidth = 2;
      if (entrySignals) {
        entrySignals.forEach(idx => {
          const xPos = x.getPixelForValue(labels[idx]);
          ctx.beginPath();
          ctx.moveTo(xPos, top);
          ctx.lineTo(xPos, bottom);
          ctx.stroke();
        });
      }
      ctx.restore();
    }
  };

  // Регистрируем плагин и обновляем график
  Chart.register(verticalLinePlugin);
  chart.update();
}

// Основная функция — загружаем данные и строим график
async function main() {
  const data = await fetchData();
  if (!data.length) return; // нет данных

  // Преобразуем время открытия в человекочитаемый вид (для подписей оси X)
  labels = data.map(item => {
    const d = new Date(item[0]);
    return d.toLocaleString(); // или другой формат
  });

  // Цены закрытия
  const closes = data.map(item => parseFloat(item[4]));

  // Скользящие средние
  const shortMA = calcMA(data, shortPeriod);
  const longMA = calcMA(data, longPeriod);

  // Ищем сигналы входа
  const signals = findEntrySignals(shortMA, longMA);

  // Рисуем график
  drawChart(closes, shortMA, longMA, signals);
}

// Запуск
main();
</script>

</body>
</html>
